const mixedTwoPairs = async (req) => {
   const { ratio = '4-6' } = req.query;
   const amount1 = Number(ratio[0]);
   const amount2 = Number(ratio[2]);
   if (amount1 == undefined || amount2 == undefined || amount1 + amount2 != 10) {
      amount1 = 4;
      amount2 = 6;
   }
   // let x;

   let counter = 0;
   let profits = [];

   let collections = await Case.find({})
      .populate({ path: 'skins', populate: { path: 'grey', model: 'Skin' } })
      .populate({ path: 'skins', populate: { path: 'light_blue', model: 'Skin' } })
      .populate({ path: 'skins', populate: { path: 'blue', model: 'Skin' } })
      .populate({ path: 'skins', populate: { path: 'purple', model: 'Skin' } })
      .populate({ path: 'skins', populate: { path: 'pink', model: 'Skin' } })
      .populate({ path: 'skins', populate: { path: 'red', model: 'Skin' } });


   // collections = collections.slice(0, 10);
   // const nOfSkins = {};
   // for (let collection of collections) {
   //    nOfSkins[collection.name] = {
   //       grey: collection.skins.grey.length,
   //       light_blue: collection.skins.light_blue.length,
   //       blue: collection.skins.blue.length,
   //       purple: collection.skins.purple.length,
   //       pink: collection.skins.pink.length,
   //       red: collection.skins.red.length,
   //    }
   // }

   // PRZESZUKIWANIE W STOSUNKU RATIO (SKINS COOPERATIVESKIN)
   for (let r = 0; r < rarities.length - 1; r++) {
      for (let collection of collections) {

         // for (let skin of collection.skins[rarities[r]]) {
         //    if (collection.skins[rarities[r + 1]].length !== 0) {

         if (collection.skins[rarities[r + 1]].length !== 0) {
            for (let quality of qualities) {
               const skin = findCheapestSkin(collection, rarities[r], quality);
               // const skinId = skin._id;
               // for (let skin of collection.skins[rarities[r]]) {
               // const skinId = skin._id;


               if (skin !== null) {
                  for (let cooperativeCollection of collections) {
                     // for (let cooperativeSkin of cooperativeCollection.skins[rarities[r]]) {
                     // if (cooperativeSkin._id !== skinId && cooperativeCollection.skins[rarities[r + 1]].length !== 0) {
                     if (cooperativeCollection.skins[rarities[r + 1]].length !== 0) {
                        for (let cooperativeQuality of qualities) {
                           const cooperativeSkin = findCheapestSkin(cooperativeCollection, rarities[r], cooperativeQuality);

                           if (cooperativeSkin !== null) {

                              let skinAvgFloat = avg_floats[quality];
                              let cooperativeSkinAvgFloat = avg_floats[cooperativeQuality];
                              if (skinAvgFloat > skin.max_float) skinAvgFloat = skin.max_float;
                              if (skinAvgFloat < skin.min_float) skinAvgFloat = skin.min_float;
                              if (cooperativeSkinAvgFloat > cooperativeSkin.max_float) cooperativeSkinAvgFloat = cooperativeSkin.max_float;
                              if (cooperativeSkinAvgFloat < cooperativeSkin.min_float) cooperativeSkinAvgFloat = cooperativeSkin.min_float;

                              const avg = Math.round(((amount1 * skinAvgFloat + amount2 * cooperativeSkinAvgFloat) / 10) * 1000) / 1000;
                              const price = skin.prices[quality];
                              const cooperativePrice = cooperativeSkin.prices[cooperativeQuality];

                              let targetedSkinsArr = [];
                              let targetedSkinsNumber = 0;
                              let total = 0;
                              let targetedSkinsQuality = []

                              // SKIN Z ILOSCIĄ RÓWNĄ AMOUNT1
                              let collName = skin.case;
                              // COOPERATYWNY SKIN (DOPEŁNIENIOWY) Z ILOSCIĄ RÓWNĄ AMOUNT2
                              let coopCollName = cooperativeSkin.case;


                              let max = 0;
                              let maxSkin = {};

                              for (let targetedCollection of collections) {
                                 if (targetedCollection.name == collName || targetedCollection.name == coopCollName) {
                                    for (let targetedSkin of targetedCollection.skins[rarities[r + 1]]) {

                                       const { min_float, max_float } = targetedSkin;
                                       const float = Math.round(((max_float - min_float) * avg + min_float) * 1000) / 1000;
                                       const targetedQuality = checkQuality(float);

                                       const targetedPrice = Math.round((targetedSkin.prices[targetedQuality] * steamTax) * 100) / 100;
                                       targetedSkin.price = targetedPrice;
                                       if (max < targetedPrice) {
                                          max = targetedPrice;
                                          maxSkin = {
                                             _id: targetedSkin._id,
                                             name: targetedSkin.name,
                                             skin: targetedSkin.skin,
                                             case: targetedSkin.case,
                                             rarity: targetedSkin.rarity,
                                             min_float: targetedSkin.min_float,
                                             max_float: targetedSkin.max_float,
                                             price: max,
                                             targetedQuality
                                          }
                                       }

                                       if (targetedCollection.name == coopCollName && targetedCollection.name == collName) {
                                          total += targetedPrice * (amount1 + amount2);
                                          targetedSkinsNumber += 1 * (amount1 + amount2);
                                       } else if (targetedCollection.name == collName) {
                                          total += targetedPrice * amount1;
                                          targetedSkinsNumber += 1 * amount1;
                                       } else if (targetedCollection.name == coopCollName) {
                                          total += targetedPrice * amount2;
                                          targetedSkinsNumber += 1 * amount2;
                                       }

                                       targetedSkinsQuality.push(targetedQuality);
                                       targetedSkinsArr.push(targetedSkin);
                                       counter += 1;
                                    }
                                 }
                              }






                              let trades = [];
                              let addToArr = false;

                              // for (let targetedSkin of targetedSkinsArr) {

                              // const targetedSkin = maxSkin;
                              const inputPrice = amount1 * price + amount2 * cooperativePrice;
                              if (inputPrice < maxSkin.price) {

                                 // const chance = Math.round(1 / targetedSkinsNumber * 100);
                                 const { min_float, max_float } = maxSkin;
                                 const float = Math.round(((max_float - min_float) * avg + min_float) * 1000) / 1000;
                                 const targetedQuality = checkQuality(float);
                                 // const avgLossPrice = (total - targetedPrice) / (targetedSkinsArr - 1);
                                 // const profitability = Math.round(((inputPrice - targetedPrice) * chance / 100 - (inputPrice - avgLossPrice) * (100 - chance) / 100) * 100) / 100;
                                 // const profitability = Math.round((inputPrice - (total / targetedSkinsNumber)) * 100) / 100;
                                 const avgPrice = total / targetedSkinsNumber;
                                 const profitability = Math.round((avgPrice - inputPrice) * 1000) / 1000;
                                 const returnPercentage = Math.round(((avgPrice) / inputPrice * 100) * 1000) / 1000;

                                 // if (skin.skin == 'Buddy' && cooperativeSkin.skin == 'Apocalypto' && quality == 'Factory New' && cooperativeQuality == 'Minimal Wear') {
                                 //    x = {
                                 //       skin,
                                 //       cooperativeSkin,
                                 //       targetedSkin,
                                 //       quality,
                                 //       cooperativeQuality,
                                 //       targetedQuality,
                                 //       price,
                                 //       cooperativePrice,
                                 //       inputPrice,
                                 //       targetedPrice: targetedSkin.price,
                                 //       rarity: rarities[r],
                                 //       targetedSkinsArr,
                                 //       targetedSkinsQuality,
                                 //       // chance,
                                 //       profitability,
                                 //       returnPercentage,
                                 //    }
                                 // }

                                 if (profitability > 0) {
                                    addToArr = true;

                                    const pom = {
                                       skin,
                                       cooperativeSkin,
                                       targetedSkin: maxSkin,
                                       quality,
                                       cooperativeQuality,
                                       targetedQuality,
                                       price,
                                       cooperativePrice,
                                       inputPrice,
                                       targetedPrice: maxSkin.price,
                                       rarity: rarities[r],
                                       targetedSkinsArr,
                                       targetedSkinsQuality,
                                       // chance,
                                       profitability,
                                       returnPercentage,
                                    }

                                    let correctPosition = false;
                                    let i = 0;
                                    while (!correctPosition && i <= trades.length - 1) {
                                       if (pom.targetedPrice > trades[i].targetedPrice) {
                                          let firstHalf = trades.slice(0, i);
                                          let secondHalf = trades.slice(i);
                                          trades = [...firstHalf, pom, ...secondHalf];
                                          correctPosition = true;
                                       }
                                       i += 1;
                                    }
                                    if (!correctPosition) {
                                       trades.push(pom);
                                       correctPosition = true;
                                    }


                                 }
                              }
                              // }


                              if (addToArr) {
                                 const pom2 = {
                                    trades,
                                    avg,
                                    total,
                                    positiveCases: trades.length,
                                    targetedSkinsNumber
                                 }

                                 if (profits.length <= 2) {
                                    profits.push(pom2);
                                 } else {
                                    let correctPosition = false;
                                    let i = 0;
                                    while (!correctPosition && i <= profits.length - 1) {

                                       if (pom2.trades[0].returnPercentage > profits[i].trades[0].returnPercentage) {
                                          let firstHalf = profits.slice(0, i);
                                          let secondHalf = profits.slice(i);
                                          profits = [...firstHalf, pom2, ...secondHalf];
                                          correctPosition = true;
                                       }
                                       i += 1;
                                    }
                                    if (!correctPosition) {
                                       profits.push(pom2);
                                       correctPosition = true;
                                    }
                                 }

                              }
                              counter += 1;
                           }



                        }
                     }
                  }
               }

               // counter += 1;
            }
            // }       
         }
      }

   }

   // for (let profit of profits) {
   //    console.log(profit.trades[0].returnPercentage)
   // }
   // console.log(x)
   let counterOpt = counter.toLocaleString()
   let positiveResults = profits.length.toLocaleString();

   console.log(counter, positiveResults)
   return { profits, counterOpt, positiveResults, amount: { amount1, amount2 } };

}